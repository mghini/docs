{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation",
    "keywords": "API Documentation The API documentation is automatically generated from source-code-level comments. Often, more information can be found by looking into the source code itself."
  },
  "articles/fonts/customrendering.html": {
    "href": "articles/fonts/customrendering.html",
    "title": "Custom Rendering",
    "keywords": "Custom Rendering Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. We are yet to priorities performance in our font loading and layout APIs. Note ImageSharp.Drawing already implements the glyph rendering for you unless you are rendering on other platforms we would recommend using the version provided by that library.. This is a more advanced topic. Implementing a glyph renderer The abstraction used by Fonts to allow implementing glyph rendering is the IGlyphRenderer and its brother IColoredGlypheRenderer (for colored emoji support). // `IColoredGlyphRenderer` implements `IGlyphRenderer` so if you don't want colored font support just implement `IGlyphRenderer`. public class CustomGlyphRenderer : IColoredGlyphRenderer { /// <summary> /// Called before any glyphs have been rendered. /// </summary> /// <param name=\"bounds\">The bounds the text will be rendered at and at whats size.</param> void IGlyphRenderer.BeginText(FontRectangle bounds) { // called before any thing else to provide access to the total required size to redner the text } /// <summary> /// Begins the glyph. /// </summary> /// <param name=\"bounds\">The bounds the glyph will be rendered at and at what size.</param> /// <param name=\"paramaters\">The set of paramaters that uniquely represents a version of a glyph in at particular font size, font family, font style and DPI.</param> /// <returns>Returns true if the glyph should be rendered othersie it returns false.</returns> bool IGlyphRenderer.BeginGlyph(FontRectangle bounds, GlyphRendererParameters paramaters) { // called before each glyph/glyph layer is rendered. // The paramaters can be used to detect the exact details // of the glyph so that duplicate glyphs could optionally // be cached to reduce processing. // You can return false to skip all the figures within the glyph (if you return false EndGlyph will still be called) } /// <summary> /// Sets the color to use for the current glyph. /// </summary> /// <param name=\"color\">The color to override the renders brush with.</param> void IColorGlyphRenderer.SetColor(GlyphColor color) { // from the IColorGlyphRenderer version, onlt called if the current glyph should override the forgound color of current glyph/layer } /// <summary> /// Begins the figure. /// </summary> void IGlyphRenderer.BeginFigure() { // called at the start of the figure within the single glyph/layer // glyphs are rendered as a serise of arcs, lines and movements // which together describe a complex shape. } /// <summary> /// Sets a new start point to draw lines from /// </summary> /// <param name=\"point\">The point.</param> void IGlyphRenderer.MoveTo(Vector2 point) { // move current point to location marked by point without describing a line; } /// <summary> /// Draw a quadratic bezier curve connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"secondControlPoint\">The second control point.</param> /// <param name=\"point\">The point.</param> void IGlyphRenderer.QuadraticBezierTo(Vector2 secondControlPoint, Vector2 point) { // describes Quadratic Bezier curve from the 'current point' using the // 'second control point' and final 'point' leaving the 'current point' // at 'point' } /// <summary> /// Draw a Cubics bezier curve connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"secondControlPoint\">The second control point.</param> /// <param name=\"thirdControlPoint\">The third control point.</param> /// <param name=\"point\">The point.</param> void IGlyphRenderer.CubicBezierTo(Vector2 secondControlPoint, Vector2 thirdControlPoint, Vector2 point) { // describes Cubic Bezier curve from the 'current point' using the // 'second control point', 'third control point' and final 'point' // leaving the 'current point' at 'point' } /// <summary> /// Draw a straight line connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"point\">The point.</param> void IGlyphRenderer.LineTo(Vector2 point) { // describes straight line from the 'current point' to the final 'point' // leaving the 'current point' at 'point' } /// <summary> /// Ends the figure. /// </summary> void IGlyphRenderer.EndFigure() { // Called after the figure has completed denoting a straight line should // be drawn from the current point to the first point } /// <summary> /// Ends the glyph. /// </summary> void IGlyphRenderer.EndGlyph() { // says the all figures have completed for the current glyph/layer. // NOTE this will be called even if BeginGlyph return false. } /// <summary> /// Called once all glyphs have completed rendering /// </summary> void IGlyphRenderer.EndText() { //once all glyphs/layers have been drawn this is called. } }"
  },
  "articles/fonts/gettingstarted.html": {
    "href": "articles/fonts/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. We are yet to priorities performance in our font loading and layout APIs. Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. Fonts Fonts provides the core to your text layout and loading subsystems. SixLabors.Fonts.FontCollection is the root type you will configure and load up with all the TrueType/OpenType/Woff fonts. (font loading is deemed expensive and should be done once and shared across multiple rasterizations) SixLabors.Fonts.Font is our currying type for passing information about your chosen font face. Loading Fonts Fonts provides several options for loading fonts, you can load then from a streams or files, we also support loading collections out of *.TTC files and well as single variants out if individual *.TTF files. We also support loading *.woff files. Minimal Example using SixLabors.Fonts; FontCollection collection = new FontCollection(); FontFamily family = collection.Install(\"path/to/font.ttf\"); Font font = family.Create(12, FontStyle.Italic); // \"font\" can now be used in calls to DrawText from our ImageSharp.Drawing library. Expanded Example using SixLabors.Fonts; FontCollection collection = new FontCollection(); collection.Install(\"path/to/font.ttf\"); collection.Install(\"path/to/font2.ttf\"); collection.Install(\"path/to/emojiFont.ttf\"); collection.InstallCollection(\"path/to/font.ttc\"); if(collection.TryFind(\"Font Name\", out FontFamily family)) if(collection.TryFind(\"Emoji Font Name\", out FontFamily emojiFamily)) { // family will not be null here Font font = family.Create(12, FontStyle.Italic); RendererOptions options = new RendererOptions(font, dpi: 72) { ApplyKerning = true, FallbackFontFamilies = new [] { emojiFamily // will be used if a particular code point doesn't exist in the font passed into the constructor. (e.g. emoji) } }; FontRectangle rect = TextMeasurer.Measure(\"Text to measure\", options); }"
  },
  "articles/fonts/index.html": {
    "href": "articles/fonts/index.html",
    "title": "Introduction",
    "keywords": "Introduction Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. We are yet to priorities performance in our drawing APIs. What is Fonts? Fonts is a font loading and layout library built primarily to provide text drawing support to ImageSharp.Drawing. Built against .NET Standard 1.3 , Fonts can be used in device, cloud, and embedded/IoT scenarios. License Fonts is licensed under under the terms of Apache License, Version 2.0 . Commercial support licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation Fonts is installed via NuGet with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.Fonts -Version VERSION_NUMBER dotnet add package SixLabors.Fonts --version VERSION_NUMBER <PackageReference Include=\"SixLabors.Fonts\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.Fonts --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio NuGet Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp.drawing/gettingstarted.html": {
    "href": "articles/imagesharp.drawing/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Warning ImageSharp.Drawing is still considered BETA quality and we still reserve the rights to change the API shapes. WE are yet to priorities performance in our drawing APIs. Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. ImageSharp.Drawing - Paths and Polygons ImageSharp.Drawing provides several classes for build and manipulating various shapes and paths. @\"SixLabors.ImageSharp.Drawing.IPath\" Root interface defining a path/polygon and the type that the rasterizer uses to generate pixel output. This SixLabors.ImageSharp.Drawing namespace contains a variety of available polygons to speed up your drawing process. In addition to the vector manipulation APIs the library also contains rasterization APIs that can convert your @\"SixLabors.ImageSharp.Drawing.IPath\"s to pixels. Drawing Polygons ImageSharp provides several options for drawing polygons whether you want to draw outlines or fill shapes. Minimal Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; Image image = ...; // create any way you like. IPath yourPolygon = new Star(x: 100.0f, y: 100.0f, prongs: 5, innerRadii: 20.0f, outerRadii:30.0f) image.Mutate( x=> x.Fill(Color.Red, yourPolygon)); // fill the star with red Expanded Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; using SixLabors.ImageSharp.PixelFormats; Image image = ...; // create any way you like. // The options are optional ShapeGraphicsOptions options = new ShapeGraphicsOptions() { ColorBlendingMode = PixelColorBlendingMode.Multiply }; IBrush brush = Brushes.Horizontal(Color.Red, Color.Blue); IPen pen = Pens.DashDot(Color.Green, 5); IPath yourPolygon = new Star(x: 100.0f, y: 100.0f, prongs: 5, innerRadii: 20.0f, outerRadii:30.0f) // draws a star with Horizontal red and blue hatching with a dash dot pattern outline. image.Mutate( x=> x.Fill(options, brush, yourPolygon) .Draw(option, pen, yourPolygon)); API Cornerstones for Polygon Rasterization Our Fill APIs always work off a Brush (some helpers create the brush for you) and will take your provided set of paths and polygons filling in all the pixels inside the vector with the color the brush provides. Our Draw APIs always work off the Pen where we processes your vector to create an outline with a certain pattern and fill in the outline with an internal brush inside the pen. Drawing Text ImageSharp.Drawing provides several options for drawing text all overloads of a single DrawText API. Our text drawing infrastructure is build on top of our Fonts library. (See SixLabors.Fonts for details on handling fonts.) Minimal Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; Image image = ...; // create any way you like. Font font = ...; // see our Fonts library for best practices on retriving one of these. string yourText = \"this is some sample text\"; image.Mutate( x=> x.DrawText(yourText, font, Color.Black, new PointF(10, 10))); Expanded Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; using SixLabors.ImageSharp.PixelFormats; Image image = ...; // create any way you like. Font font = ...; // see our Fonts library for best practices on retriving one of these. // The options are optional TextGraphicsOptions options = new TextGraphicsOptions() { ApplyKerning = true, TabWidth = 8, // a tab renders as 8 spaces wide WrapTextWidth = 100, // greater than zero so we will word wrap at 100 pixels wide HorizontalAlignment = HorizontalAlignment.Right // right align }; IBrush brush = Brushes.Horizontal(Color.Red, Color.Blue); IPen pen = Pens.DashDot(Color.Green, 5); string text = \"sample text\"; // draws a star with Horizontal red and blue hatching with a dash dot pattern outline. image.Mutate( x=> x.DrawText(options, text, font, brush, pen, new PointF(100, 100));"
  },
  "articles/imagesharp.drawing/index.html": {
    "href": "articles/imagesharp.drawing/index.html",
    "title": "Introduction",
    "keywords": "Introduction Warning ImageSharp.Drawing is still considered BETA quality and we reserve the right to change the API shape. We are yet to prioritize performance in our drawing APIs. What is ImageSharp.Drawing? ImageSharp.Drawing is a library built on top of ImageSharp to providing 2D Drawing extensions. ImageSharp.Drawing is designed from the ground up to be flexible and extensible. The library provides API endpoints for common vector and text processing operations adding the building blocks for building custom images. Built against .NET Standard 1.3 , ImageSharp.Drawing can be used in device, cloud, and embedded/IoT scenarios. License ImageSharp.Drawing is licensed under under the terms of Apache License, Version 2.0 . Commercial support licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp.Drawing is installed via NuGet with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp.Drawing -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp.Drawing --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp.Drawing\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp.Drawing --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio NuGet Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp.web/gettingstarted.html": {
    "href": "articles/imagesharp.web/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. Setup and Configuration Once installed you will need to add the following code to ConfigureServices and Configure in your Startup.cs file. This installs the the default service and options. public void ConfigureServices(IServiceCollection services) { // Add the default service and options. services.AddImageSharp(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // Add the image processing middleware. app.UseImageSharp(); } The fluent configuration is flexible allowing you to configure a multitude of different options. For example you can add the default service and custom options. // Add the default service and custom options. services.AddImageSharp( options => { // You only need to set the options you want to change here // All properties have been listed for demonstration purposes // only. options.Configuration = Configuration.Default; options.MemoryStreamManager = new RecyclableMemoryStreamManager(); options.BrowserMaxAge = TimeSpan.FromDays(7); options.CacheMaxAge = TimeSpan.FromDays(365); options.CachedNameLength = 8; options.OnParseCommandsAsync = _ => Task.CompletedTask; options.OnBeforeSaveAsync = _ => Task.CompletedTask; options.OnProcessedAsync = _ => Task.CompletedTask; options.OnPrepareResponseAsync = _ => Task.CompletedTask; }); Or you can fine-grain control adding the default options and configure other services. // Fine-grain control adding the default options and configure other services. services.AddImageSharp() .RemoveProcessor<FormatWebProcessor>() .RemoveProcessor<BackgroundColorWebProcessor>(); There are also factory methods for each builder that will allow building from configuration files. // Use the factory methods to configure the PhysicalFileSystemCacheOptions services.AddImageSharp() .Configure<PhysicalFileSystemCacheOptions>(options => { options.CacheFolder = \"different-cache\"; }); Full Configuration API options are available here ."
  },
  "articles/imagesharp.web/imagecaches.html": {
    "href": "articles/imagesharp.web/imagecaches.html",
    "title": "Image Caches",
    "keywords": "Image Caches ImageSharp.Web caches the result of any valid processing operation to allow the fast retrieval of future identical requests. The cache is smart, storing additional metadata to allow the detection of updated source images and can be configured to a fine degree to determine the duration a processed image should be cached for. Note It is possible to configure your own image cache by implementing and registering your own version of the @\"SixLabors.ImageSharp.Web.Caching.IImageCache\" interface. The following caches are available for the middleware. PhysicalFileSystemCache The @\"SixLabors.ImageSharp.Web.Caching.PhysicalFileSystemCache\" stores processed image files in the web root folder. This is the default cache installed when configuring the middleware. Images are cached in separate folders based upon a hash of the request URL. this allows the caching of millions of image files without slowing down the file system. AzureBlobStorageImageCache This cache allows the caching of image files using Azure Blob Storage and is available as an external package installable via NuGet Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp.Web.Providers.Azure -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp.Web.Providers.Azure --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp.Web.Providers.Azure\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp.Web.Providers.Azure --version VERSION_NUMBER Once installed the cache @SixLabors.ImageSharp.Web.Caching.Azure.AzureBlobStorageCacheOptions can be configured as follows: // Configure and register the container. // Alteratively use `appsettings.json` to represent the class and bind those settings. .Configure<AzureBlobStorageCacheOptions>(options => { options.ConnectionString = {AZURE_CONNECTION_STRING}; options.ContainerName = {AZURE_CONTAINER_NAME}; // Optionally create the cache container on startup if not already created. AzureBlobStorageCache.CreateIfNotExists(options, PublicAccessType.None); }) .SetCache<AzureBlobStorageImageCache>() Images are cached using a hash of the request URL as the blob name. All appropriate metadata is stored in the blob properties to correctly serve the blob with the correct response headers."
  },
  "articles/imagesharp.web/imageproviders.html": {
    "href": "articles/imagesharp.web/imageproviders.html",
    "title": "Image Providers",
    "keywords": "Image Providers ImageSharp.Web determines the the location of a source image to process via the registration and application of image providers. Note It is possible to configure your own image provider by implementing and registering your own version of the @\"SixLabors.ImageSharp.Web.Providers.IImageProvider\" interface. The following providers are available for the middleware. Multiples providers can be registered and will be queried for a URL match in the order of registration. PhysicalFileSystemProvider The @\"SixLabors.ImageSharp.Web.Providers.PhysicalFileSystemProvider\" will allow the processing and serving of image files from the web root folder. This is the default provider installed when configuring the middleware. Url matching for this provider follows the same rules as conventional static files. AzureBlobStorageImageProvider This provider allows the processing and serving of image files from Azure Blob Storage and is available as an external package installable via NuGet Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp.Web.Providers.Azure -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp.Web.Providers.Azure --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp.Web.Providers.Azure\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp.Web.Providers.Azure --version VERSION_NUMBER Once installed the provider @\"SixLabors.ImageSharp.Web.Providers.Azure.AzureBlobContainerClientOptions\" can be configured as follows: // Configure and register the container. // Alteratively use `appsettings.json` to represent the class and bind those settings. .Configure<AzureBlobStorageImageProviderOptions>(options => { // The \"BlobContainers\" collection allows registration of multiple containers. options.BlobContainers.Add(new AzureBlobContainerClientOptions { ConnectionString = {AZURE_CONNECTION_STRING}, ContainerName = {AZURE_CONTAINER_NAME} }); }) .AddProvider<AzureBlobStorageImageProvider>() Url requests are matched in accordance to the following rule: /{CONTAINER_NAME}/{BLOB_FILENAME}"
  },
  "articles/imagesharp.web/index.html": {
    "href": "articles/imagesharp.web/index.html",
    "title": "Introduction",
    "keywords": "Introduction What is ImageSharp.Web? ImageSharp.Web is a high performance ASP.NET Core Middleware built on top of ImageSharp that allows the processing and caching of image requests via a simple API. ImageSharp.Web is designed from the ground up to be flexible and extensible. The library provides API endpoints for common image processing operations and the building blocks to allow for the development of additional extensions to add image sources, caching mechanisms or even your own processing API. License Imagesharp.Web is licensed under under the terms of Apache License, Version 2.0 . Commercial support licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp.Web is installed via NuGet with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp.Web -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp.Web --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp.Web\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp.Web --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio NuGet Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp.web/processingcommands.html": {
    "href": "articles/imagesharp.web/processingcommands.html",
    "title": "Processing Commands",
    "keywords": "Processing Commands The ImageSharp.Web processing API is imperative. This means that the order in which you supply the individual processing operations is the order in which they are are compiled and applied. This allows the API to be very flexible, allowing you to combine processes in any order. Note It is possible to configure your own processing command pipeline by implementing and registering your own version of the @\"SixLabors.ImageSharp.Web.Commands.IRequestParser\" interface. The following processors are built into the middleware. In addition extension points are available to register you own command processors. Resize Allows the resizing of images. {PATH_TO_YOUR_IMAGE}?width=300 {PATH_TO_YOUR_IMAGE}?width=300&height=120&rxy=30,30 {PATH_TO_YOUR_IMAGE}?width=50&height=50&rsampler=nearest&rmode=stretch Resize commands represent the @\"SixLabors.ImageSharp.Processing.ResizeOptions\" class. width The width of the image in px. Use only one dimension to preseve the aspect ratio. height The height of the image in px. Use only one dimension to preseve the aspect ratio. rmode The @\"SixLabors.ImageSharp.Processing.ResizeMode\" to use. rsampler The @\"SixLabors.ImageSharp.Processing.Processors.Transforms.IResampler\" sampler to use. bicubic @\"SixLabors.ImageSharp.Processing.KnownResamplers.Bicubic\" nearest @\"SixLabors.ImageSharp.Processing.KnownResamplers.NearestNeighbor\" box @\"SixLabors.ImageSharp.Processing.KnownResamplers.Box\" mitchell @\"SixLabors.ImageSharp.Processing.KnownResamplers.MitchellNetravali\" catmull @\"SixLabors.ImageSharp.Processing.KnownResamplers.CatmullRom\" lanczos2 @\"SixLabors.ImageSharp.Processing.KnownResamplers.Lanczos2\" lanczos3 @\"SixLabors.ImageSharp.Processing.KnownResamplers.Lanczos3\" lanczos5 @\"SixLabors.ImageSharp.Processing.KnownResamplers.Lanczos5\" lanczos8 @\"SixLabors.ImageSharp.Processing.KnownResamplers.Lanczos8\" welch @\"SixLabors.ImageSharp.Processing.KnownResamplers.Welch\" robidoux @\"SixLabors.ImageSharp.Processing.KnownResamplers.Robidoux\" robidouxsharp @\"SixLabors.ImageSharp.Processing.KnownResamplers.RobidouxSharp\" spline @\"SixLabors.ImageSharp.Processing.KnownResamplers.Spline\" triangle @\"SixLabors.ImageSharp.Processing.KnownResamplers.Triangle\" hermite @\"SixLabors.ImageSharp.Processing.KnownResamplers.Hermite\" rxy The center position to anchor the image center point to. ranchor The @\"SixLabors.ImageSharp.Processing.AnchorPositionMode\" to use. compand Whether to compress and expand individual pixel colors values to/from a linear color space when processing. Format Allows the encoding of the output image to a new image format. The available formats depend on your configuration settings. {PATH_TO_YOUR_IMAGE}?format=jpg {PATH_TO_YOUR_IMAGE}?format=gif {PATH_TO_YOUR_IMAGE}?format=png {PATH_TO_YOUR_IMAGE}?format=bmp {PATH_TO_YOUR_IMAGE}?format=tga Quality Allows the encoding of the output image at the given quality. For Jpeg this ranges from 1—100. {PATH_TO_YOUR_IMAGE}?quality=90 {PATH_TO_YOUR_IMAGE}?format=jpg&quality=42 Note Only certain formats support adjustable quality. This is a constraint of individual image standards not the API. Background Color Allows the changing of the background color of transparent images. {PATH_TO_YOUR_IMAGE}?bgcolor=FFFF00 {PATH_TO_YOUR_IMAGE}?bgcolor=C1FF0080 {PATH_TO_YOUR_IMAGE}?bgcolor=red {PATH_TO_YOUR_IMAGE}?bgcolor=128,64,32 {PATH_TO_YOUR_IMAGE}?bgcolor=128,64,32,16"
  },
  "articles/imagesharp/configuration.html": {
    "href": "articles/imagesharp/configuration.html",
    "title": "Configuration",
    "keywords": "Configuration ImageSharp contains a @\"SixLabors.ImageSharp.Configuration\" class designed to allow the configuration of application wide settings. This class provides a range of configuration opportunities that cover format support, memory and parallelization settings and more. @\"SixLabors.ImageSharp.Configuration.Default\" is a shared singleton that is used to configure the default behavior of the ImageSharp library but it is possible to provide your own instances depended upon your required setup. Injection Points. The @\"SixLabors.ImageSharp.Configuration\" class can be injected in several places within the API to allow overriding global values. This provides you with the means to apply fine grain control over your processing activity to cater for your environment. The @\"SixLabors.ImageSharp.Image\" and @\"SixLabors.ImageSharp.Image`1\" constructors. The @\"SixLabors.ImageSharp.Image.Load*\" methods and variants. The @\"SixLabors.ImageSharp.Processing.ProcessingExtensions.Mutate*\" and @\"SixLabors.ImageSharp.Processing.ProcessingExtensions.Clone*\" methods. Configuring ImageFormats As mentioned in Image Formats it is possible to configure your own format collection for the API to consume. For example, if you wanted to restrict the library to support a specific collection of formats you would configure the library as follows: var configuration = new Configuration( new PngConfigurationModule(), new JpegConfigurationModule(), new GifConfigurationModule(), new BmpConfigurationModule(), new TgaConfigurationModule() new CustomFormatConfigurationModule());"
  },
  "articles/imagesharp/gettingstarted.html": {
    "href": "articles/imagesharp/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. ImageSharp Images ImageSharp provides several classes for storing pixel data: @\"SixLabors.ImageSharp.Image\" A pixel format agnostic image container used for general processing operations. @\"SixLabors.ImageSharp.Image`1\" A generic image container that allows per-pixel access. In addition there are classes available that represent individual image frames: @\"SixLabors.ImageSharp.ImageFrame\" A pixel format agnostic image frame container. @\"SixLabors.ImageSharp.ImageFrame`1\" A generic image frame container that allows per-pixel access. @\"SixLabors.ImageSharp.IndexedImageFrame`1\" A generic image frame used for indexed image pixel data where each pixel buffer value represents an index in a color palette. For more information on pixel formats please see the following documentation . Loading and Saving Images ImageSharp provides several options for loading and saving images to cover different scenarios. The library automatically detects the source image format upon load and it is possible to dictate which image format to save an image pixel data to. using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; // Open the file automatically detecting the file type to decode it. // Our image is now in an uncompressed, file format agnostic, structure in-memory as // a series of pixels. using (Image image = Image.Load(\"foo.jpg\")) { // Resize the image in place and return it for chaining. // 'x' signifies the current image processing context. image.Mutate(x => x.Resize(image.Width / 2, image.Height / 2)); // The library automatically picks an encoder based on the file extension then // encodes and write the data to disk. // You can optionally set the encoder to choose. image.Save(\"bar.jpg\"); } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. In this very basic example you are actually utilizing several core ImageSharp features: Image Formats by loading and saving an image. Image Processors by calling Mutate() and Resize() Initializing New Images using SixLabors.ImageSharp; using SixLabors.ImageSharp.PixelFormats; using SixLabors.ImageSharp.Processing; int width = 640; int height = 480; // Creates a new image with empty pixel data. using(var image = new Image<Rgba32>(width, height)) { // Do your drawing in here... } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. In this example you are utilizing the following core ImageSharp feature: Pixel Formats by using Rgba32 API Cornerstones The easiest way to work with ImageSharp is to utilize our extension methods: @\"SixLabors.ImageSharp\" for basic operations and primitives. @\"SixLabors.ImageSharp.Processing\" for Mutate() and Clone() . All the processing extensions (eg. Resize(...) ) live within this namespace. Performance Achieving near-to-native performance is a major goal for the SixLabors team, and thanks to the improvements brought by the RyuJIT runtime, it's no longer mission impossible. We have made great progress and are constantly working on improvements. At the moment it's pretty hard to define fair benchmarks comparing GDI+ (aka. System.Drawing on Windows) and ImageSharp, because of the differences between the algorithms being used. Generally speaking, we are more feature rich, producing better quality. We hope we can match the corresponding algorithm parameters, and present some very specific benchmark results soon. If you are experiencing a significant performance gap between System.Drawing and ImageSharp for basic use-cases, there is a high chance that essential SIMD optimizations are not utilized. A few troubleshooting steps to try: Check the value of Vector.IsHardwareAccelerated . If the output is false, it means there is no SIMD support in your runtime! Make sure your code runs on 64bit! Older .NET Framework versions are using the legacy runtime on 32 bits, having no built-in SIMD support."
  },
  "articles/imagesharp/imageformats.html": {
    "href": "articles/imagesharp/imageformats.html",
    "title": "Image Formats",
    "keywords": "Image Formats Out of the box ImageSharp supports the following image formats: Jpeg Png Bmp Gif Tga ImageSharp's API however, is designed to support extension by the registration of additional IImageFormat implementations. Loading and Saving Specific Image Formats Image<TPixel> represents raw pixel data, stored in a contiguous memory block. It does not \"remember\" the original image format. ImageSharp identifies image formats (Jpeg, Png, Gif etc.) by IImageFormat instances. There are several overloads of Image.Load capable of returning the format as an out parameter. It's possible to pass that value to image.Save after performing the operation: IImageFormat format; using (var image = Image.Load(inputStream, out format)) { image.Mutate(c => c.Resize(30, 30)); image.Save(outputStream, format); } Note ImageSharp provides common extension methods to save an image into a stream using a specific format. image.SaveAsJpeg() (shortcut for image.Save(new JpegEncoder()) ) image.SaveAsPng() (shortcut for image.Save(new PngEncoder()) ) image.SaveAsGif() (shortcut for image.Save(new GifEncoder()) ) image.SaveAsBmp() (shortcut for image.Save(new BmpEncoder()) ) image.SaveAsTga() (shortcut for image.Save(new TgaEncoder()) ) A Deeper Overview of ImageSharp Format Management Real life image streams are usually stored / transferred in standardized formats like Jpeg, Png, Bmp, Gif etc. An image format is represented by an IImageFormat implementation. IImageDecoder is responsible for decoding streams (and files) in into Image<TPixel> . ImageSharp can auto-detect the image formats of streams/files based on their headers, selecting the correct IImageFormat (and thus IImageDecoder ). This logic is implemented by IImageFormatDetector 's. IImageEncoder is responsible for writing Image<TPixel> into a stream using a given format. Decoders/encoders and IImageFormatDetector 's are mapped to image formats in ImageFormatsManager . It's possible to register new formats, or drop existing ones. See Configuration for more details. Metadata-only Decoding Sometimes it's worth to efficiently decode image metadata ignoring the memory and CPU heavy pixel information inside the stream. ImageSharp allows this by using one of the several Image.Identify overloads: using (IImageInfo imageInfo = Image.Identify(inputStream)) { Console.WriteLine($\"{imageInfo.Width}x{imageInfo.Height} | BPP: {imageInfo.PixelType.BitsPerPixel}\"); } See IImageInfo for more details about the identification result. Note that Image<TPixel> also implements IImageInfo . Working with Encoders Image formats are usually defined by complex standards allowing multiple representations for the same image. ImageSharp allows parameterizing the encoding process: IImageEncoder implementations are stateless, lightweight parametric objects. This means that if you want to encode a Png in a specific way (eg. changing the compression level), you need to new-up a custom PngEncoder instance. Choosing the right encoder parameters allows to balance between conflicting tradeoffs: Image file size Encoder speed Image quality Each encoder offers options specific to the image format it represents."
  },
  "articles/imagesharp/index.html": {
    "href": "articles/imagesharp/index.html",
    "title": "Introduction",
    "keywords": "Introduction What is ImageSharp? ImageSharp is a new, fully featured, fully managed, cross-platform, 2D graphics library. Designed to simplify image processing, ImageSharp brings you an incredibly powerful yet beautifully simple API. ImageSharp is designed from the ground up to be flexible and extensible. The library provides API endpoints for common image processing operations and the building blocks to allow for the development of addtional operations. Built against .NET Standard 1.3 , ImageSharp can be used in device, cloud, and embedded/IoT scenarios. License Imagesharp is licensed under under the terms of Apache License, Version 2.0 . Commercial support licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp is installed via NuGet with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio NuGet Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp/memorymanagement.html": {
    "href": "articles/imagesharp/memorymanagement.html",
    "title": "Memory Management",
    "keywords": "Memory Management ImageSharp seems to retain ~300—400 MB of managed memory even after disposing all my images. Is this a memory leak? By default, ImageSharp uses ArrayPool's for performance reasons, however this behavior is fully configurable. All large buffers are managed by the @\"SixLabors.ImageSharp.Memory.MemoryAllocator\" implementation associated to @\"SixLabors.ImageSharp.Configuration\"'s @\"SixLabors.ImageSharp.Configuration.MemoryAllocator\" property. We are using @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator\" by default, in order to utilize the benefits of array pooling: Less pressure on GC, because buffers are being reused most of the time Reduced LOH fragmentation When working with unclean buffers is acceptable, we can spare on GC-s array cleaning behavior too Summary : pooling helps us to reduce CPU work and increase throughput for the cost of a larger memory footprint. Working in Memory Constrained Environments Sometimes having ~300 MB memory footprint is not an option. Let's mention a few cases: When horizontal scaling is achieved by having multiple memory constrained containers in a cloud environment. Mobile applications. Before scaling down pooling behavior because of unwanted OutOfMemoryException -s in a cloud or desktop environment: Keep in mind that image processing is a memory intensive application! This may affect your scaling strategy. We don't recommend using containers with 1 GB or smaller memory limit! Make sure that you are running your service in a 64 bit process ! There are several pre-defined factory methods to create an @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator\" instance for memory constrained environments. For example @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator.CreateWithModeratePooling\" might be suitable in most constrained situations: Configuration.Default.MemoryAllocator = ArrayPoolMemoryAllocator.CreateWithModeratePooling(); Of course, you may also configure a MemoryAllocator on your own @\"SixLabors.ImageSharp.Configuration\" instance. You can find benchmark results in the original PR which may help to select you a configuration, but they are bit outdated, because our throughput has improved since then! Releasing Pools Programmatically If your application uses ImageSharp sporadically (eg. generating some images on startup, or on other non-frequent use-cases), you may want to release the retained pools using @\"SixLabors.ImageSharp.Memory.MemoryAllocator.ReleaseRetainedResources\": Configuration.Default.MemoryAllocator.ReleaseRetainedResources(); Using Multiple MemoryAllocator Instances in the Same Process You need to create and maintain your own @\"SixLabors.ImageSharp.Configuration\" instance, setting a specific MemoryAllocator on it. It's possible to pass custom Configuration instances to methods across our whole API."
  },
  "articles/imagesharp/pixelbuffers.html": {
    "href": "articles/imagesharp/pixelbuffers.html",
    "title": "Working with Pixel Buffers",
    "keywords": "Working with Pixel Buffers Setting individual pixels using indexers A very basic and readable way for manipulating individual pixels is to use the indexer either on Image<T> or ImageFrame<T> : using (Image<Rgba32> image = new Image<Rgba32>(400, 400)) { image[200, 200] = Rgba32.White; // also works on ImageFrame<T> } The idexer is much faster than the .GetPixel(x, y) and .SetPixel(x,y) methods of System.Drawing but, it's still quite slow. Efficient pixel manipulation If you want to achieve killer speed in your own low-level pixel manipulation routines, you should utilize the per-row methods. These methods take advantage of the brand-new Span<T> -based memory manipulation primitives from System.Memory , providing a fast, yet safe low-level solution to manipulate pixel data. This is how you can implement efficient row-by-row pixel manipulation: using SixLabors.ImageSharp; // ... using (Image<Rgba32> image = new Image<Rgba32>(400, 400)) { for (int y = 0; y < image.Height; y++) { Span<Rgba32> pixelRowSpan = image.GetPixelRowSpan(y); for (int x = 0; x < image.Width; x++) { pixelRowSpan[x] = new Rgba32(x/255, y/255, 50, 255); } } } Span<T> limitations Please be aware that Span<T> has a very specific limitation : it is a stack-only type! Read the Is There Anything Span Can’t Do?! section in this article for more details. A short summary of the limitations: Span can only live on the execution stack. Span cannot be boxed or put on the heap. Span cannot be used as a generic type argument. Span cannot be an instance field of a type that itself is not stack-only. Span cannot be used within asynchronous methods. Non-conformant code: Span<Rgba32> span = image.GetRowSpan(y); await Task.Run(() => { // ☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠ // ☠☠☠ BANG! YOU HAVE CAPTURED A SPAN ON THE HEAP! ☠☠☠ for (int i = 0; i < span.Length; i++) { span[i] = /* ... */; } }); Exporting raw pixel data from an Image<T> You can use @\"SixLabors.ImageSharp.Image`1.TryGetSinglePixelSpan*\" to access the whole contigous pixel buffer, for example, to copy the pixel data into an array. For large, multi-megapixel images, however, the data must be accessed and copied per row: if(image.TryGetSinglePixelSpan(out var pixelSpan)) { Rgba32[] pixelArray = pixelSpan.ToArray(); } Or: Rgba32[] pixelArray = /* your pixel buffer being reused */ if(image.TryGetSinglePixelSpan(out var pixelSpan)) { pixelSpan().CopyTo(pixelArray); } Or: if(image.TryGetSinglePixelSpan(out var pixelSpan)) { byte[] rgbaBytes = MemoryMarshal.AsBytes(pixelSpan()).ToArray(); } Loading raw pixel data into an Image<T> Rgba32[] rgbaData = GetMyRgbaArray(); using (var image = Image.LoadPixelData(rgbaData)) { // Work with the image } byte[] rgbaBytes = GetMyRgbaBytes(); using (var image = Image.LoadPixelData<Rgba32>(rgbaBytes)) { // Work with the image }"
  },
  "articles/imagesharp/pixelformats.html": {
    "href": "articles/imagesharp/pixelformats.html",
    "title": "Pixel Formats",
    "keywords": "Pixel Formats Why is @\"SixLabors.ImageSharp.Image`1\" a generic class? We support multiple pixel formats just like System.Drawing does. However, unlike their closed PixelFormat enumeration, our solution is extensible. A pixel is basically a small value object (struct), describing the color at a given point according to a pixel model we call Pixel Format. Image<TPixel> represents a pixel graphic bitmap stored as a generic, discontiguous memory block of pixels, of total size image.Width * image.Height . Note that while the image memory should be considered discontiguous by default, if the image is small enough (less than ~4GB in memory, on 64-bit), it will be stored in a single, continuous memory block for improved performance. The reason why there is additional support for discontiguous buffers is to allow images at super high resolution, which couldn't otherwise be loaded due to limitations to the maximum size of objects in the .NET runtime, even on 64-bit systems. In the case of multi-frame images multiple bitmaps are stored in image.Frames as ImageFrame<TPixel> instances. Choosing Pixel Formats Take a look at the various pixel formats available under @\"SixLabors.ImageSharp.PixelFormats#structs\" After picking the pixel format of your choice, use it as a generic argument for @\"SixLabors.ImageSharp.Image`1\", for example, by instantiating Image<Bgr24> . Defining Custom Pixel Formats Creating your own pixel format is a case of defining a struct implementing @\"SixLabors.ImageSharp.PixelFormats.IPixel`1\" and using it as a generic argument for @\"SixLabors.ImageSharp.Image`1\". Baseline batched pixel-conversion primitives are provided via @\"SixLabors.ImageSharp.PixelFormats.PixelOperations`1\" but it is possible to override those baseline versions with your own optimized implementation. I have a monochrome image and I want to store it in a compact way. Can I store a pixel on a single bit? No. Our architecture does not allow sub-byte pixel formats at the moment. This feature is incredibly complex to implement, and you are going to pay the price of the low memory footprint in processing speed / CPU load. Can I decode into pixel formats like CMYK or CIELAB ? Unfortunately it's not possible and is unlikely to be in the future. Many image processing operations expect the pixels to be laid out in-memory in RGBA format. To manipulate images in exotic colorspaces we would have to translate each pixel to-and-from the colorspace multiple times, which would result in unusable performance and a loss of color information."
  },
  "articles/imagesharp/processing.html": {
    "href": "articles/imagesharp/processing.html",
    "title": "Processing Image Operations",
    "keywords": "Processing Image Operations The ImageSharp processing API is imperative. This means that the order in which you supply the individual processing operations is the order in which they are are compiled and applied. This allows the API to be very flexible, allowing you to combine processes in any order. Details of built in processing extensions can be found in the @\"SixLabors.ImageSharp.Processing\" documentation. Processing operations are implemented using one of two available method calls. Mutate and Clone The difference being that the former applies the given processing operations to the current image whereas the latter applies the operations to a deep copy of the original image. For example: Mutate using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { // Resize the given image in place and return it for chaining. // 'x' signifies the current image processing context. image.Mutate(x => x.Resize(image.Width / 2, image.Height / 2)); image.Save(outStream); } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. Clone using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { // Create a deep copy of the given image, resize it, and return it for chaining. using (Image copy = image.Clone(x => x.Resize(image.Width / 2, image.Height / 2))) { copy.Save(outStream); } } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. Common Examples Examples of common operations can be found in the following documentation pages. Resizing images using different options."
  },
  "articles/imagesharp/resize.html": {
    "href": "articles/imagesharp/resize.html",
    "title": "Resizing Images",
    "keywords": "Resizing Images Resizing an image is probably the most common processing operation that applications use. ImageSharp offers an incredibly flexible collection of resize options that allow developers to choose sizing algorithms, sampling algorithms, and gamma handling as well as other options. The Basics Resizing an image involves the process of creating and iterating through the pixels of a target image and sampling areas of a source image to choose what color to implement for each pixel. The sampling algorithm chosen affects the target color and can dramatically alter the result. Different samplers are usually chosen based upon the use case - For example NearestNeigbor is often used for fast, low quality thumbnail generation, Lanczos3 for high quality thumbnails due to it's sharpening effect, and Spline for high quality enlargement due to it's smoothing effect. With ImageSharp we default to Bicubic as it is a very robust algorithm offering good quality output when both reducing and enlarging images but you can easily set the algorithm when processing. A full list of out-of-the-box sampling algorithms can be found here : Resize the given image using the default Bicubic sampler. using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { int width = image.Width / 2; int height = image.Height / 2; image.Mutate(x => x.Resize(width, height)); image.Save(outPath); } Resize the given image using the Lanczos3 sampler: using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Formats.Png; //used only for the PNG encoder below using (Image image = Image.Load(inStream)) { int width = image.Width / 2; int height = image.Height / 2; image.Mutate(x => x.Resize(width, height, KnownResamplers.Lanczos3)); image.Save(outStream, new PngEncoder());//Replace Png encoder with the file format of choice } Note If you pass 0 as any of the values for width and height dimensions then ImageSharp will automatically determine the correct opposite dimensions size to preserve the original aspect ratio. Advanced Resizing In addition to basic resizing operations ImageSharp also offers more advanced features. Check out the @\"SixLabors.ImageSharp.Processing.ResizeOptions\" class for details."
  },
  "index.html": {
    "href": "index.html",
    "title": "Six Labors Documentation.",
    "keywords": "Six Labors Documentation. We aim to provide modern, cross-platform, incredibly powerful yet beautifully simple graphics libraries. Built against .NET Standard, our libraries can be used in device, cloud, and embedded/IoT scenarios. You can find tutorials, examples and API details covering all Six Labors projects. API documentation Detailed documentation for the entire API available across our projects. Conceptual Documentation Our graphics libraries are split into different projects. They cover different concerns separately, but there is strong cohesion in order to provide the best developer experience. You can find documentation for each project in the links below. ImageSharp Fully featured 2D graphics API Learn More > ImageSharp.Drawing 2D polygon Manipulation and Drawing. Learn More > ImageSharp.Web ASP.NET Core Image Manipulation Middleware. Learn More > Fonts Font Loading and Drawing API. Learn More > Examples Repository We have implemented short self-contained sample projects for a few specific use cases, including: Avatar with rounded corners Crops rounded corners of a source image leaving a nice rounded avatar. Draw watermark on image Draw water mark over an image automaticaly scaling the font size to fill the avalible space. Change default encoder options Provides an example on how you go about switching out the registered encoder for a file format and changing its default options in the process. Draw text along a path Draw some text following the contours of a path."
  }
}